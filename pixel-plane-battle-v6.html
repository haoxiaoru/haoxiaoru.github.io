<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2.5D Pixel Plane Battle - Boss Battles!</title>
        <style>
        /* --- Base Styles (mostly unchanged) --- */
        html, body { margin: 0; padding: 0; overflow: hidden; height: 100%; background-color: #111; font-family: 'Courier New', Courier, monospace; }
        #game-container { position: relative; width: 100%; height: 100%; background-color: #000033; overflow: hidden; }
        canvas { image-rendering: pixelated; image-rendering: crisp-edges; position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; color: white; font-size: 16px; padding: 10px; box-sizing: border-box; text-shadow: 1px 1px 1px #000; }
        #score { position: absolute; top: 10px; left: 10px; }
        #health { position: absolute; top: 10px; right: 10px; }
        /* --- Adjusted Level Display --- */
        #level {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap; /* Prevent wrapping */
        }
        /* --- End Level Display Adjustment --- */
        #game-over, #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background-color: rgba(0, 0, 0, 0.7); color: white; text-align: center; z-index: 10; }
        button { background-color: #4CAF50; border: none; color: white; padding: 10px 20px; text-align: center; text-decoration: none; display: inline-block; font-size: 16px; margin: 20px 0; cursor: pointer; border-radius: 5px; font-family: 'Courier New', Courier, monospace; pointer-events: auto; }
        h1 { font-size: 32px; margin-bottom: 20px; color: #ffde59; text-shadow: 2px 2px 4px #000; }
        .controls { margin-top: 20px; font-size: 14px; color: #ccc; }

        /* --- Boss Health Bar --- */
        #boss-health-container {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 50%;
            max-width: 400px;
            height: 20px;
            background-color: rgba(100, 100, 100, 0.7);
            border: 1px solid #fff;
            border-radius: 5px;
            display: none; /* Hidden by default */
            z-index: 5;
        }
        #boss-health-bar {
            width: 100%;
            height: 100%;
            background-color: #ff4444;
            border-radius: 4px;
            transition: width 0.2s linear; /* Smooth decrease */
        }
        #level-message { /* For "Level Cleared" etc. */
             position: absolute;
             top: 40%;
             left: 50%;
             transform: translate(-50%, -50%);
             font-size: 40px;
             color: #ffff99;
             text-shadow: 3px 3px 6px #000;
             display: none; /* Hidden by default */
             z-index: 11;
             text-align: center;
        }

    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="background-layer"></canvas>
        <canvas id="game-layer"></canvas>
        <div id="ui-layer">
            <div id="score">分数: 0</div>
            <div id="health">生命值: 100</div>
            <div id="level">关卡: 1 | 分数: 0 / 0</div>
            <div id="boss-health-container">
                 <div id="boss-health-bar"></div>
            </div>
            <div id="level-message"></div>
        </div>
        <div id="start-screen">
            <h1>2.5D 像素飞机大战</h1>
            <button id="start-button">开始游戏</button>
            <div class="controls">
                方向键/WASD 控制移动 | 按住空格键发射子弹
            </div>
        </div>
        <div id="game-over" style="display: none;">
            <h1>游戏结束</h1>
            <div id="final-score">分数: 0</div>
            <button id="restart-button">重新开始</button>
        </div>
    </div>

    <script>
        // --- Audio Setup ---
        let audioCtx = null;
        let masterGain = null;
        const SOUND_VOLUME = 0.35; // Slightly reduced volume

        function initializeAudio() {
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    masterGain = audioCtx.createGain();
                    masterGain.gain.setValueAtTime(SOUND_VOLUME, audioCtx.currentTime);
                    masterGain.connect(audioCtx.destination);
                } catch (e) { console.error("Web Audio API not supported", e); }
            }
            if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
        }
        // --- End Audio Setup ---

        // Game constants
        const PLANE_SPEED = 5;
        const BULLET_SPEED = 8;
        const ENEMY_BULLET_SPEED = 5;
        const BOSS_BULLET_SPEED = 6;
        const BASE_ENEMY_SPEED = 1.5;
        const CLOUD_SPEED = 1;
        const PLAYER_FIRE_COOLDOWN = 150;
        const LEVEL_TRANSITION_TIME = 3000; // 3 seconds between boss defeat and next level

        // Game state
        let gameState = 'start_screen'; // 'start_screen', 'playing', 'boss_intro', 'boss_fight', 'level_transition', 'game_over'
        let score = 0;
        let playerHealth = 100;
        let level = 1;
        let scoreNeededForNextLevel = 0; // Calculated in startGame/levelTransition
        let enemies = [];
        let playerBullets = [];
        let enemyBullets = [];
        let clouds = [];
        let lastEnemySpawn = 0;
        let enemySpawnInterval = 1500;
        let lastEnemyShot = 0;
        let keyState = {};
        let playerImmune = false;
        let immunityTime = 0;
        let lastPlayerShotTime = 0;
        let currentBoss = null;
        let levelTransitionTimer = 0;

        // Canvas setup
        const bgCanvas = document.getElementById('background-layer');
        const bgCtx = bgCanvas.getContext('2d');
        const gameCanvas = document.getElementById('game-layer');
        const gameCtx = gameCanvas.getContext('2d');

        // UI elements
        const scoreElement = document.getElementById('score');
        const healthElement = document.getElementById('health');
        const levelElement = document.getElementById('level');
        const gameOverScreen = document.getElementById('game-over');
        const startScreen = document.getElementById('start-screen');
        const finalScoreElement = document.getElementById('final-score');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const bossHealthContainer = document.getElementById('boss-health-container');
        const bossHealthBar = document.getElementById('boss-health-bar');
        const levelMessageElement = document.getElementById('level-message');


        // Player object
        const player = { x: 100, y: 100, width: 48, height: 48, frameCount: 0, visible: true };

        // --- Pixel Art Creation ---
        function createPlayerImage() { /* ... (no changes) ... */
            const canvas = document.createElement('canvas');
            canvas.width = 48; canvas.height = 48;
            const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = '#4488ee'; ctx.fillRect(20, 8, 8, 32); // Fuselage
            ctx.fillStyle = '#55aaff'; ctx.fillRect(12, 20, 24, 8); // Wings
            ctx.fillStyle = '#88ddff'; ctx.fillRect(22, 12, 4, 6); // Cockpit
            ctx.fillStyle = '#4488ee'; ctx.fillRect(20, 4, 8, 4); // Tail base
            ctx.fillStyle = '#ffdd44'; ctx.fillRect(8, 20, 4, 8); ctx.fillRect(36, 20, 4, 8); // Wing tips
            ctx.fillStyle = '#ffdd44'; ctx.fillRect(20, 0, 8, 4); // Tail fin top
            ctx.fillStyle = '#ff5533'; ctx.fillRect(22, 40, 4, 4); ctx.fillStyle = '#ffaa33'; ctx.fillRect(22, 44, 4, 4); // Engine flame base
            return canvas;
         }
        function createEnemyType1Image() { /* ... (no changes) ... */
            const canvas = document.createElement('canvas');
            canvas.width = 40; canvas.height = 40;
            const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = '#dd3322'; ctx.fillRect(16, 8, 8, 24); // Fuselage
            ctx.fillStyle = '#ee5544'; ctx.fillRect(8, 16, 24, 8); // Wings
            ctx.fillStyle = '#222222'; ctx.fillRect(18, 12, 4, 6); // Cockpit
            ctx.fillStyle = '#dd3322'; ctx.fillRect(16, 4, 8, 4); // Tail base
            ctx.fillStyle = '#222222'; ctx.fillRect(4, 16, 4, 8); ctx.fillRect(32, 16, 4, 8); // Wing tips
            return canvas;
        }
        function createEnemyType2Image() { /* ... (no changes) ... */
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = '#22aa44'; ctx.fillRect(12, 6, 8, 20); // Fuselage
            ctx.fillStyle = '#44cc66'; ctx.fillRect(4, 12, 24, 6); // Swept Wings
            ctx.fillStyle = '#ccffdd'; ctx.fillRect(14, 8, 4, 4); // Cockpit
            ctx.fillStyle = '#22aa44'; ctx.fillRect(12, 2, 8, 4); // Tail
            ctx.fillStyle = '#ffff88'; ctx.fillRect(0, 12, 4, 6); ctx.fillRect(28, 12, 4, 6); // Wing tips
            return canvas;
        }
        function createEnemyType3Image() { /* ... (no changes) ... */
            const canvas = document.createElement('canvas');
            canvas.width = 52; canvas.height = 48;
            const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = '#663399'; ctx.fillRect(20, 4, 12, 40); // Wide Fuselage
            ctx.fillStyle = '#8844bb'; ctx.fillRect(8, 18, 36, 12); // Wide Wings
            ctx.fillStyle = '#dd99ff'; ctx.fillRect(24, 10, 4, 8); // Cockpit
            ctx.fillStyle = '#663399'; ctx.fillRect(20, 0, 12, 4); // Tail base
            ctx.fillStyle = '#442266'; ctx.fillRect(0, 18, 8, 12); ctx.fillRect(44, 18, 8, 12); // Wing ends
            ctx.fillStyle = '#ffcc66'; ctx.fillRect(20, 44, 12, 4); // Engine glow maybe?
            return canvas;
        }
        function createEnemyType4Image() { /* ... (no changes) ... */
            const canvas = document.createElement('canvas');
            canvas.width = 60; canvas.height = 50;
            const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = '#888888'; ctx.fillRect(15, 5, 30, 40); // Main body
            ctx.fillStyle = '#aaaaaa'; ctx.fillRect(5, 15, 50, 15); // Wide wings
            ctx.fillStyle = '#666666'; ctx.fillRect(25, 0, 10, 5); // Tail fin base
            ctx.fillStyle = '#cccccc'; ctx.fillRect(28, 10, 4, 8); // Cockpit (simple)
            ctx.fillStyle = '#555555'; ctx.fillRect(0, 15, 5, 15); ctx.fillRect(55, 15, 5, 15); // Wing End Caps
            ctx.fillStyle = '#ff9955'; ctx.fillRect(18, 45, 8, 5); ctx.fillRect(34, 45, 8, 5); // Engines
            return canvas;
        }
        function createEnemyType5Image() { /* ... (no changes) ... */
            const canvas = document.createElement('canvas');
            canvas.width = 28; canvas.height = 36; // Taller than wide
            const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = '#ddcc00'; ctx.fillRect(10, 2, 8, 32); // Long thin fuselage
            ctx.fillStyle = '#ffff44'; ctx.fillRect(2, 10, 24, 6); // Delta wings
            ctx.fillStyle = '#ff8800'; ctx.fillRect(12, 0, 4, 4); // Nose cone
            ctx.fillStyle = '#aaaa00'; ctx.fillRect(6, 28, 16, 4); // Stabilizers near back
            ctx.fillStyle = '#ffffff'; ctx.fillRect(12, 6, 4, 6); // Cockpit
            return canvas;
        }
        function createBulletImage() { /* ... (no changes) ... */
            const canvas = document.createElement('canvas');
            canvas.width = 8; canvas.height = 16;
            const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = '#ffdd44'; ctx.fillRect(2, 0, 4, 12);
            ctx.fillStyle = '#ff8800'; ctx.fillRect(0, 8, 8, 4);
            ctx.fillStyle = '#ff5500'; ctx.fillRect(2, 12, 4, 4);
            return canvas;
        }
        function createEnemyBulletImage() { /* ... (no changes) ... */
            const canvas = document.createElement('canvas');
            canvas.width = 8; canvas.height = 16;
            const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = '#ff3333'; ctx.fillRect(2, 0, 4, 12);
            ctx.fillStyle = '#aa2222'; ctx.fillRect(0, 8, 8, 4);
            ctx.fillStyle = '#ff7777'; ctx.fillRect(2, 12, 4, 4);
            return canvas;
        }
        // --- NEW Boss Bullet Image ---
        function createBossBulletImage() {
            const canvas = document.createElement('canvas');
            canvas.width = 12; canvas.height = 20;
            const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = '#cc00ff'; ctx.fillRect(4, 0, 4, 16); // Core
            ctx.fillStyle = '#ff88ff'; ctx.fillRect(2, 4, 8, 12); // Glow
            ctx.fillStyle = '#8800aa'; ctx.fillRect(0, 10, 12, 6); // Base
            ctx.fillStyle = '#ffffff'; ctx.fillRect(4, 16, 4, 4); // Tip
            return canvas;
        }
        // --- NEW Boss Image ---
        function createBossImage() {
            const canvas = document.createElement('canvas');
            canvas.width = 120; canvas.height = 90; // Larger!
            const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
            // Main Body (Darker)
            ctx.fillStyle = '#444455'; ctx.fillRect(30, 10, 60, 70);
            // Wings (Swept Back)
            ctx.fillStyle = '#666677'; ctx.beginPath(); ctx.moveTo(0, 30); ctx.lineTo(30, 30); ctx.lineTo(50, 15); ctx.lineTo(0, 15); ctx.closePath(); ctx.fill(); // Left Wing
            ctx.beginPath(); ctx.moveTo(120, 30); ctx.lineTo(90, 30); ctx.lineTo(70, 15); ctx.lineTo(120, 15); ctx.closePath(); ctx.fill(); // Right Wing
             // Secondary Wing Layer (Lower/Broader)
            ctx.fillStyle = '#555566'; ctx.fillRect(10, 40, 100, 20);
            // Cockpit (Prominent, Red Glow)
            ctx.fillStyle = '#222233'; ctx.fillRect(45, 25, 30, 15);
            ctx.fillStyle = '#ff0033'; ctx.fillRect(50, 28, 20, 9);
             // Engines (Large, Glowing)
            ctx.fillStyle = '#333344'; ctx.fillRect(35, 75, 15, 15); ctx.fillRect(70, 75, 15, 15); // Engine Housing
            ctx.fillStyle = '#ff5500'; ctx.fillRect(38, 80, 9, 10); ctx.fillRect(73, 80, 9, 10); // Engine Glow
             // Tail Fins (Dual)
            ctx.fillStyle = '#666677'; ctx.fillRect(35, 0, 10, 15); ctx.fillRect(75, 0, 10, 15);
            // Details/Greebles
            ctx.fillStyle = '#9999aa'; ctx.fillRect(0, 15, 5, 15); ctx.fillRect(115, 15, 5, 15); // Wing Tips
            ctx.fillStyle = '#bbbbcc'; ctx.fillRect(58, 50, 4, 20); // Antenna?
            return canvas;
        }
        function createCloudImage() { /* ... (no changes) ... */
             const canvas = document.createElement('canvas');
            const size = Math.floor(Math.random() * 40) + 60;
            canvas.width = size; canvas.height = size / 2;
            const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            const numBubbles = Math.floor(Math.random() * 3) + 3;
            for (let i = 0; i < numBubbles; i++) {
                const x = Math.random() * (size - 20) + 10;
                const y = Math.random() * (size / 2 - 10) + 5;
                const radius = Math.random() * 15 + 10;
                ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill();
            }
            return canvas;
         }
        function createExplosionImage(frame, size = 64) { // Allow size variation
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = false;
            const colors = ['#ff5500', '#ffaa00', '#ffff00', '#ffffff'];
            const center = size / 2;
            const baseRadius = size / 6.4; // Scale radius with size

            if (frame === 0) {
                ctx.fillStyle = colors[0]; ctx.beginPath(); ctx.arc(center, center, baseRadius * 1.0, 0, Math.PI * 2); ctx.fill();
            } else if (frame === 1) {
                ctx.fillStyle = colors[0]; ctx.beginPath(); ctx.arc(center, center, baseRadius * 2.0, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = colors[1]; ctx.beginPath(); ctx.arc(center, center, baseRadius * 1.2, 0, Math.PI * 2); ctx.fill();
            } else if (frame === 2) {
                ctx.fillStyle = colors[0]; ctx.beginPath(); ctx.arc(center, center, baseRadius * 3.0, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = colors[1]; ctx.beginPath(); ctx.arc(center, center, baseRadius * 2.0, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = colors[2]; ctx.beginPath(); ctx.arc(center, center, baseRadius * 1.0, 0, Math.PI * 2); ctx.fill();
            } else if (frame === 3) {
                ctx.fillStyle = colors[1]; ctx.beginPath(); ctx.arc(center, center, baseRadius * 2.5, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = colors[2]; ctx.beginPath(); ctx.arc(center, center, baseRadius * 1.5, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = colors[3]; ctx.beginPath(); ctx.arc(center, center, baseRadius * 0.5, 0, Math.PI * 2); ctx.fill();
            }
            return canvas;
        }

        // Pre-create images
        const playerImage = createPlayerImage();
        const bulletImage = createBulletImage();
        const enemyBulletImage = createEnemyBulletImage();
        const bossBulletImage = createBossBulletImage(); // New
        const bossImage = createBossImage(); // New
        const smallExplosionFrames = [ createExplosionImage(0), createExplosionImage(1), createExplosionImage(2), createExplosionImage(3) ];
        const largeExplosionFrames = [ createExplosionImage(0, 128), createExplosionImage(1, 128), createExplosionImage(2, 128), createExplosionImage(3, 128) ]; // For boss

        const enemyImages = { type1: createEnemyType1Image(), type2: createEnemyType2Image(), type3: createEnemyType3Image(), type4: createEnemyType4Image(), type5: createEnemyType5Image() };

        // Enemy & Boss Definitions
        const enemyTypes = {
            type1: { image: enemyImages.type1, width: 40, height: 40, baseHealth: 1, baseSpeed: BASE_ENEMY_SPEED, points: 10, shootChance: 0.3, allowedPatterns: [0, 1] },
            type2: { image: enemyImages.type2, width: 32, height: 32, baseHealth: 1, baseSpeed: BASE_ENEMY_SPEED * 1.5, points: 15, shootChance: 0.2, allowedPatterns: [0, 1] },
            type3: { image: enemyImages.type3, width: 52, height: 48, baseHealth: 3, baseSpeed: BASE_ENEMY_SPEED * 0.8, points: 30, shootChance: 0.4, allowedPatterns: [0, 2] },
            type4: { image: enemyImages.type4, width: 60, height: 50, baseHealth: 5, baseSpeed: BASE_ENEMY_SPEED * 0.6, points: 50, shootChance: 0.25, allowedPatterns: [0, 3] },
            type5: { image: enemyImages.type5, width: 28, height: 36, baseHealth: 1, baseSpeed: BASE_ENEMY_SPEED * 2.5, points: 25, shootChance: 0.1, allowedPatterns: [1, 2] }
        };

        const bossStats = {
            image: bossImage, width: 120, height: 90,
            baseHealth: 50,
            speed: BASE_ENEMY_SPEED * 0.5,
            points: 500,
            attackPatterns: ['burst', 'spread'],

            // --- UPDATED Base values ---
            baseTimeBetweenAttacks: 450,  // Halved from 1800 for double frequency baseline
            baseBurstCount: 4,
            baseBurstDelay: 120,
            baseSpreadCount: 5,
        };

        // Explosions array
        let explosions = [];

        // --- Improved Sound Effects ---
        function playSound(type, freq, duration, vol, decay = 0.05, targetFreq = freq, rampType = 'linear') {
            if (!audioCtx || !masterGain) return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                if (rampType === 'linear') {
                    osc.frequency.linearRampToValueAtTime(targetFreq, audioCtx.currentTime + duration);
                } else {
                    osc.frequency.exponentialRampToValueAtTime(Math.max(0.1, targetFreq), audioCtx.currentTime + duration); // Avoid 0
                }
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.001, audioCtx.currentTime + duration + decay); // Faster fade out

                osc.connect(gain); gain.connect(masterGain);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + duration + decay);
            } catch (e) { console.error("playSound error:", e); }
        }

        function playNoise(duration, startVol, endVol = 0.001) {
             if (!audioCtx || !masterGain) return;
             try {
                 const bufferSize = audioCtx.sampleRate * duration;
                 const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                 const output = buffer.getChannelData(0);
                 for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1; // White noise

                 const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
                 const noiseGain = audioCtx.createGain();
                 noiseGain.gain.setValueAtTime(startVol, audioCtx.currentTime);
                 noiseGain.gain.exponentialRampToValueAtTime(endVol, audioCtx.currentTime + duration);
                 noise.connect(noiseGain); noiseGain.connect(masterGain);
                 noise.start(audioCtx.currentTime);
             } catch(e) { console.error("playNoise error:", e); }
        }

        function playShootSound() {
            playSound('triangle', 1200, 0.03, 0.2, 0.03, 800); // Quick high pitch down
            playNoise(0.05, 0.1, 0.01); // Short noise burst
        }

        function playExplosionSound(volumeScale = 1.0) {
            playSound('sawtooth', 300, 0.2 * volumeScale, 0.5 * volumeScale, 0.2 * volumeScale, 50, 'exponential'); // Descending growl
            playNoise(0.4 * volumeScale, 0.5 * volumeScale, 0.01); // Longer noise burst
            playSound('square', 100, 0.1 * volumeScale, 0.3 * volumeScale, 0.3 * volumeScale); // Low thump
        }

        function playBossExplosionSound() {
             playExplosionSound(1.5); // Louder basic explosion
             playSound('sawtooth', 500, 0.8, 0.6, 0.8, 30, 'exponential'); // Longer descending growl
             setTimeout(() => playExplosionSound(1.2), 150); // Delayed secondary explosion
             setTimeout(() => playExplosionSound(1.0), 300); // Delayed tertiary explosion
             playNoise(1.0, 0.7, 0.01); // Long loud noise
        }

        function playPlayerHitSound() {
            playSound('square', 200, 0.15, 0.6, 0.1, 80); // Quick descending harsh tone
            playNoise(0.1, 0.4);
        }

        function playEnemyHitSound() {
            playSound('square', 1500, 0.02, 0.1, 0.03, 1000); // Very short, high 'tink'
        }
         function playBossHitSound() {
            playSound('sawtooth', 400, 0.05, 0.3, 0.05, 300); // Deeper 'thud'
            playNoise(0.06, 0.2);
        }

        function playLevelUpSound() { // More fanfare-like
            playSound('sine', 523, 0.1, 0.4, 0.05); // C5
            setTimeout(() => playSound('sine', 659, 0.1, 0.4, 0.05), 100); // E5
            setTimeout(() => playSound('sine', 784, 0.1, 0.4, 0.05), 200); // G5
            setTimeout(() => playSound('sine', 1046, 0.2, 0.5, 0.1), 300); // C6 (Higher)
        }
        function playLevelClearSound() {
            playLevelUpSound(); // Reuse level up sound for now
             // Add a longer sustained note
            setTimeout(() => playSound('triangle', 784, 0.5, 0.4, 0.3), 500); // G5 sustain
        }

        function playGameOverSound() {
             playSound('sawtooth', 150, 0.8, 0.6, 0.5, 50, 'exponential'); // Long low descending growl
             playNoise(1.0, 0.5);
        }
        function playButtonClickSound() { playSound('sine', 1000, 0.03, 0.2, 0.03); }
        // --- End Sound Effects ---

        // --- Game Logic Functions ---

        function calculateScoreNeeded(currentLevel) {
             // Acknowledging the score carry-over and boss bonus issue.
             // This formula focuses on making the *difference* between level thresholds grow aggressively.
             // We need (Target_N - Target_N-1) > PointsNeededInLevel_N-1 + BossBonus_N-1 + ScoreInflation

             const baseRequirement = 300; // Keep a low base for Level 1 accessibility
             const levelExponent = 3.3;   // Use a very steep exponent to rapidly increase the gap
             const scalingFactor = 180;   // A significant factor to amplify the exponent's effect

             // Example Calculation (Thresholds):
             // Level 1 -> 2 needs total score: 300 + 1^3.3 * 180 = 300 + 180 = 480
             // Level 2 -> 3 needs total score: 300 + 2^3.3 * 180 = 300 + (9.84 * 180) = 300 + 1771 = ~2071
             // Level 3 -> 4 needs total score: 300 + 3^3.3 * 180 = 300 + (37.07 * 180) = 300 + 6673 = ~6973
             // Level 4 -> 5 needs total score: 300 + 4^3.3 * 180 = 300 + (91.95 * 180) = 300 + 16551 = ~16851

             // Simulation of Points Needed *Within* the Level:
             // - Start Lvl 1: Score=0. Target=480. Need 480 points.
             // - Defeat Boss 1 (500*1=500 pts): Score becomes 480+500 = 980.
             // - Start Lvl 2: Score=980. Target=2071. Need 2071-980 = 1091 points. (More than Lvl 1's 480)
             // - Defeat Boss 2 (500*2=1000 pts): Score becomes 2071+1000 = 3071.
             // - Start Lvl 3: Score=3071. Target=6973. Need 6973-3071 = 3902 points. (Much more than Lvl 2's 1091)
             // - Defeat Boss 3 (500*3=1500 pts): Score becomes 6973+1500 = 8473.
             // - Start Lvl 4: Score=8473. Target=16851. Need 16851-8473 = 8378 points. (Much more than Lvl 3's 3902)

             // This progression shows a clear increase in points required *during* each level.

             return Math.floor(baseRequirement + Math.pow(currentLevel, levelExponent) * scalingFactor);
        }


        function updateUI() {
            scoreElement.textContent = '分数: ' + score;
            healthElement.textContent = '生命值: ' + Math.max(0, playerHealth);
            // Updated level display format
            levelElement.textContent = `关卡: ${level} | 分数: ${score} / ${scoreNeededForNextLevel}`;

            // Boss health bar
            if (gameState === 'boss_fight' && currentBoss) {
                bossHealthContainer.style.display = 'block';
                const healthPercent = Math.max(0, (currentBoss.health / currentBoss.maxHealth) * 100);
                bossHealthBar.style.width = healthPercent + '%';
            } else {
                bossHealthContainer.style.display = 'none';
            }
        }

        function showLevelMessage(message, duration = 2000) {
             levelMessageElement.textContent = message;
             levelMessageElement.style.display = 'block';
             setTimeout(() => {
                 levelMessageElement.style.display = 'none';
             }, duration);
        }


        function generateClouds() { /* ... (no changes) ... */
             if (clouds.length < 15 && Math.random() < 0.02) {
                clouds.push({
                    x: Math.random() * gameCanvas.width, y: -100,
                    image: createCloudImage(), speed: Math.random() * 0.5 + 0.5, depth: Math.random() * 0.5 + 0.5
                });
            }
         }

        function generateEnemies() {
            const now = Date.now();
            if (now - lastEnemySpawn > enemySpawnInterval) {
                lastEnemySpawn = now;
                enemySpawnInterval = Math.max(200, 1200 - level * 40); // Spawn faster, higher cap

                let possibleTypes = ['type1'];
                if (level >= 2) possibleTypes.push('type2'); // Introduce earlier
                if (level >= 4) possibleTypes.push('type3');
                if (level >= 6) possibleTypes.push('type4');
                if (level >= 8) possibleTypes.push('type5');
                const randomTypeKey = possibleTypes[Math.floor(Math.random() * possibleTypes.length)];
                const type = enemyTypes[randomTypeKey];
                const movementPattern = type.allowedPatterns[Math.floor(Math.random() * type.allowedPatterns.length)];

                const enemy = {
                    type: randomTypeKey,
                    x: Math.random() * (gameCanvas.width - type.width), y: -type.height,
                    width: type.width, height: type.height,
                    health: type.baseHealth + Math.floor(level / 3), // Scale health a bit more
                    speed: type.baseSpeed * (1 + level * 0.08), // Scale speed a bit more
                    image: type.image, movementPattern: movementPattern,
                    patternPhase: Math.random() * Math.PI * 2,
                    patternDirection: (Math.random() < 0.5 ? 1 : -1),
                    points: type.points, shootChance: type.shootChance * (1 + level * 0.05) // Slightly increase shoot chance
                };
                enemies.push(enemy);
            }
        }

        function enemyShoot() {
            const now = Date.now();
            const baseInterval = Math.max(300, 1500 - level * 50); // Shoot check interval
            if (now - lastEnemyShot > baseInterval) {
                 lastEnemyShot = now;
                for (const enemy of enemies) {
                    if (enemy.y > 0 && enemy.y < gameCanvas.height * 0.8 && Math.random() < enemy.shootChance) {
                        enemyBullets.push({ x: enemy.x + enemy.width / 2 - 4, y: enemy.y + enemy.height, width: 8, height: 16, image: enemyBulletImage, speed: ENEMY_BULLET_SPEED });
                    }
                }
            }
        }

        function addExplosion(x, y, large = false) {
            const frames = large ? largeExplosionFrames : smallExplosionFrames;
            const size = large ? 128 : 64;
            explosions.push({ x: x - size/2, y: y - size/2, width: size, height: size, frame: 0, frameTime: 0, frames: frames });
        }

        function spawnBoss() {
            // --- Calculate Scaled Stats based on Level ---
            const health = Math.floor(bossStats.baseHealth * (1 + (level - 1) * 0.6));
            const points = bossStats.points * level;

            // Scale attack speed: faster attacks on higher levels, starting from the new lower base. Minimum 300ms.
            const timeBetweenAttacks = Math.max(300, bossStats.baseTimeBetweenAttacks - (level - 1) * 75);

            const burstCount = bossStats.baseBurstCount + Math.floor((level - 1) / 1.5);
            const burstDelay = Math.max(50, bossStats.baseBurstDelay - (level - 1) * 10);
            const spreadCount = bossStats.baseSpreadCount + Math.floor((level - 1) / 1.8) * 2;

            // *** INCREASED SPEED ***: Multiply the base scaled speed by an additional factor.
            const speed = bossStats.speed * (1 + (level - 1) * 0.08) * 1.8; // <--- Added * 1.8 for faster base movement

            // --- Create the Boss Object ---
            currentBoss = {
                image: bossStats.image,
                width: bossStats.width,
                height: bossStats.height,
                attackPatterns: bossStats.attackPatterns,

                x: gameCanvas.width / 2 - bossStats.width / 2,
                y: -bossStats.height - 20,
                targetY: 50,
                health: health,
                maxHealth: health,
                points: points,
                speed: speed, // Use the newly calculated faster speed

                timeBetweenAttacks: timeBetweenAttacks,
                burstCount: burstCount,
                burstDelay: burstDelay,
                spreadCount: spreadCount,

                moveDirection: 1,
                currentAttackPattern: bossStats.attackPatterns[0],
                attackCounter: 0,
                nextAttackSwitchTime: Date.now() + 12000 + Math.random() * 6000,

                hasReachedPosition: false,
                lastAttackTime: Date.now(),
            };

            console.log(`Spawning Level ${level} Boss: Health=${health}, Speed=${speed.toFixed(2)}, Attack Delay=${timeBetweenAttacks}ms, Burst=${burstCount}x${burstDelay}ms, Spread=${spreadCount}`);
            playLevelUpSound();
        }

        function updateBoss() {
            if (!currentBoss) return;

            const canvasWidth = gameCanvas.width;
            const now = Date.now();

            // --- Movement ---
            // Initial Descent
            if (!currentBoss.hasReachedPosition) {
                currentBoss.y += currentBoss.speed * 0.7; // Descent speed (can remain unchanged or adjusted slightly if needed)
                if (currentBoss.y >= currentBoss.targetY) {
                    currentBoss.y = currentBoss.targetY;
                    currentBoss.hasReachedPosition = true;
                    currentBoss.lastAttackTime = now - currentBoss.timeBetweenAttacks - 1; // Trigger first attack sooner
                    console.log("Boss reached position, preparing immediate attack.");
                }
            } else { // Horizontal Movement (only after reaching position)
                 currentBoss.x += currentBoss.speed * currentBoss.moveDirection; // Uses the increased speed

                 // *** NEW: Random Direction Change Logic ***
                 // Add a small chance to randomly change direction *before* hitting the edge.
                 const RANDOM_CHANGE_CHANCE = 0.008; // Adjust this probability (e.g., 0.01 = 1% chance per frame)
                 if (Math.random() < RANDOM_CHANGE_CHANCE) {
                     currentBoss.moveDirection *= -1; // Flip direction
                 }

                 // --- Edge Reversal Logic (Still Necessary) ---
                 // If it hits an edge after moving (and potentially after a random flip), force reversal.
                 if (currentBoss.x <= 0 && currentBoss.moveDirection < 0) {
                     currentBoss.moveDirection = 1; // Force right
                     currentBoss.x = 0; // Prevent going off-screen
                 } else if (currentBoss.x >= canvasWidth - currentBoss.width && currentBoss.moveDirection > 0) {
                     currentBoss.moveDirection = -1; // Force left
                     currentBoss.x = canvasWidth - currentBoss.width; // Prevent going off-screen
                 }
            }

            // --- Attack Pattern Switching (No changes needed here) ---
            if (now > currentBoss.nextAttackSwitchTime && currentBoss.hasReachedPosition) {
                 const currentIndex = currentBoss.attackPatterns.indexOf(currentBoss.currentAttackPattern);
                 const nextIndex = (currentIndex + 1) % currentBoss.attackPatterns.length;
                 currentBoss.currentAttackPattern = currentBoss.attackPatterns[nextIndex];
                 currentBoss.nextAttackSwitchTime = now + 8000 + Math.random() * 4000;
                 currentBoss.attackCounter = 0;
                 console.log("Boss switching to pattern:", currentBoss.currentAttackPattern);
            }

            // --- Attacking (No changes needed here) ---
            if (currentBoss.hasReachedPosition && now - currentBoss.lastAttackTime > currentBoss.timeBetweenAttacks) {
                 if (currentBoss.currentAttackPattern === 'burst') {
                    // Check if enough time passed for the next shot in the burst OR the initial delay between bursts
                    if (now - currentBoss.lastAttackTime >= (currentBoss.attackCounter > 0 ? currentBoss.burstDelay : currentBoss.timeBetweenAttacks)) {
                         if (currentBoss.attackCounter < currentBoss.burstCount) {
                            const bulletX = currentBoss.x + currentBoss.width / 2 - 6;
                            const bulletY = currentBoss.y + currentBoss.height - 10;
                            const bulletSpeed = BOSS_BULLET_SPEED * (1 + (level - 1) * 0.05);
                            enemyBullets.push({ x: bulletX, y: bulletY, width: 12, height: 20, image: bossBulletImage, speed: bulletSpeed });
                            playSound('triangle', 600, 0.04, 0.25, 0.04, 500);
                            currentBoss.lastAttackTime = now; // Reset time ONLY when a bullet is fired
                            currentBoss.attackCounter++;
                            // If this was the last bullet of the burst, reset counter for next time
                            if (currentBoss.attackCounter >= currentBoss.burstCount) {
                                currentBoss.attackCounter = 0;
                                // Don't reset lastAttackTime here, let the main timeBetweenAttacks delay control the start of the next burst
                            }
                         }
                         // Removed the redundant else block that just reset the counter.
                    }
                 }
                 else if (currentBoss.currentAttackPattern === 'spread') {
                     const spreadAngle = Math.PI / (currentBoss.spreadCount + 2);
                     const startAngle = -spreadAngle * (currentBoss.spreadCount - 1) / 2;
                     const originX = currentBoss.x + currentBoss.width / 2;
                     const originY = currentBoss.y + currentBoss.height - 10;
                     const bulletSpeed = BOSS_BULLET_SPEED * (1 + (level - 1) * 0.05);
                     for(let i = 0; i < currentBoss.spreadCount; i++) {
                         const angle = startAngle + i * spreadAngle;
                         const dx = Math.sin(angle);
                         const dy = Math.cos(angle);
                         enemyBullets.push({
                             x: originX - 6, y: originY, width: 12, height: 20,
                             image: bossBulletImage,
                             speed: bulletSpeed * 0.9, // Base speed (unused if dx/dy)
                             dx: dx * bulletSpeed * 0.6, // Horizontal component
                             dy: dy * bulletSpeed * 0.9  // Vertical component
                         });
                     }
                     playSound('sawtooth', 350, 0.12, 0.35, 0.08);
                     currentBoss.lastAttackTime = now; // Reset timer after firing the spread
                     currentBoss.attackCounter = 0; // Reset counter (though not used by spread like burst)
                 }
            }
        } // End updateBoss function


        // *** NEW FUNCTION: levelTransition ***
        function levelTransition() {
            console.log(`Level ${level} cleared! Score: ${score}`);
            gameState = 'level_transition';
            score += currentBoss.points; // Add boss points AFTER checking win condition
            level++;
            scoreNeededForNextLevel = calculateScoreNeeded(level); // Calculate for the *next* level

            // Clear bullets, keep explosions
            playerBullets = [];
            enemyBullets = [];
            currentBoss = null; // Remove the defeated boss

            showLevelMessage(`关卡 ${level - 1} 已清除!`, LEVEL_TRANSITION_TIME - 500);
            playLevelClearSound();
            updateUI(); // Update score/level display immediately

            levelTransitionTimer = setTimeout(() => {
                gameState = 'playing';
                console.log("Starting Level", level, "Score needed:", scoreNeededForNextLevel);
                // Reset enemy spawn timer for the new level
                lastEnemySpawn = Date.now();
                enemySpawnInterval = Math.max(200, 1200 - level * 40);
            }, LEVEL_TRANSITION_TIME);
        }


        // *** WRAPPED COLLISION LOGIC IN A FUNCTION ***
        function checkCollisions() {
            const canvasWidth = gameCanvas.width;
            const canvasHeight = gameCanvas.height;

            // Player bullets hitting enemies (only in 'playing' state)
            if (gameState === 'playing') {
                for (let i = playerBullets.length - 1; i >= 0; i--) {
                    const bullet = playerBullets[i];
                    if (!bullet) continue; // Safety check

                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (!enemy) continue; // Safety check

                        if (
                            bullet.x < enemy.x + enemy.width && bullet.x + bullet.width > enemy.x &&
                            bullet.y < enemy.y + enemy.height && bullet.y + bullet.height > enemy.y
                        ) {
                            playerBullets.splice(i, 1); // Remove bullet
                            enemy.health--;
                            if (enemy.health <= 0) {
                                score += enemy.points;
                                addExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                                playExplosionSound(0.8); // Slightly quieter for normal enemies
                                enemies.splice(j, 1); // Remove enemy
                            } else {
                                playEnemyHitSound(); // Enemy hit but not destroyed
                            }
                            updateUI();
                            break; // Bullet hit an enemy, stop checking this bullet against other enemies
                        }
                    }
                }
            }

            // Player bullets hitting BOSS (only in 'boss_fight' state)
            // *** ADDED CHECK: currentBoss.hasReachedPosition ***
            if (gameState === 'boss_fight' && currentBoss && currentBoss.hasReachedPosition) { // Boss must be in position to take damage
                for (let i = playerBullets.length - 1; i >= 0; i--) {
                     const bullet = playerBullets[i]; if (!bullet) continue;
                     if (/* collision check */
                         bullet.x < currentBoss.x + currentBoss.width && bullet.x + bullet.width > currentBoss.x &&
                         bullet.y < currentBoss.y + currentBoss.height && bullet.y + bullet.height > currentBoss.y
                     ) {
                         currentBoss.health--; playerBullets.splice(i, 1); playBossHitSound(); updateUI(); // Update health bar

                         if (currentBoss.health <= 0) {
                             // Don't add score here yet, do it in levelTransition
                             addExplosion(currentBoss.x + currentBoss.width / 2, currentBoss.y + currentBoss.height / 2, true); // Large explosion
                             playBossExplosionSound();
                             levelTransition(); // Handle level clear logic
                             // This return IS NOW legal because it's inside the checkCollisions function
                             return; // Stop further collision checks this frame as we are transitioning
                         }
                         break; // Bullet hit boss, no need to check other bullets this frame if needed
                     } // Closing brace for collision check 'if'
                 } // Closing brace for 'for' loop
            } // Closing brace for 'if (gameState === 'boss_fight'...)'


            // Enemy/Boss bullets hitting player
            if (!playerImmune && player.visible && (gameState === 'playing' || gameState === 'boss_fight')) {
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    const bullet = enemyBullets[i];
                    if (/* collision check */
                        bullet.x < player.x + player.width && bullet.x + bullet.width > player.x &&
                        bullet.y < player.y + player.height && bullet.y + bullet.height > player.y
                    ) {
                        enemyBullets.splice(i, 1); playerHealth -= (bullet.image === bossBulletImage ? 15 : 10); // Boss bullets hurt more
                        playPlayerHitSound(); updateUI(); playerImmune = true; immunityTime = Date.now();
                        if (playerHealth <= 0) { gameOver(); return; } // Return early from checkCollisions
                        break; // Player got hit, no need to check other bullets this frame
                    }
                }
            }

            // Enemies hitting player (only in 'playing' state)
            if (!playerImmune && player.visible && gameState === 'playing') {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (/* collision check */
                       enemy.x < player.x + player.width && enemy.x + enemy.width > player.x &&
                       enemy.y < player.y + player.height && enemy.y + enemy.height > player.y
                    ) {
                        addExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2); playExplosionSound();
                        playerHealth -= 20; playPlayerHitSound(); enemies.splice(i, 1); updateUI(); playerImmune = true; immunityTime = Date.now();
                        if (playerHealth <= 0) { gameOver(); return; } // Return early from checkCollisions
                        break; // Player hit by enemy
                    }
                }
            }
             // BOSS hitting player (only in 'boss_fight' state) - Still active even during descent
            if (!playerImmune && player.visible && gameState === 'boss_fight' && currentBoss) {
                 if (/* collision check */
                    currentBoss.x < player.x + player.width && currentBoss.x + currentBoss.width > player.x &&
                    currentBoss.y < player.y + player.height && currentBoss.y + currentBoss.height > player.y
                 ) {
                     playerHealth -= 40; // Major damage!
                     playPlayerHitSound();
                     addExplosion(player.x + player.width / 2, player.y + player.height / 2);
                     playExplosionSound(0.8);
                     updateUI();
                     playerImmune = true; immunityTime = Date.now();
                     if (playerHealth <= 0) { gameOver(); return; } // Return early from checkCollisions
                 }
             }


            // Check immunity timer
            if (playerImmune && Date.now() - immunityTime > 1000) { playerImmune = false; }
        } // *** END OF checkCollisions FUNCTION ***


        // Update game state
        function update() {
            // Always update clouds and explosions regardless of state (except start/game over)
             if (gameState !== 'start_screen' && gameState !== 'game_over') {
                 // Update clouds
                 for (let i = clouds.length - 1; i >= 0; i--) {
                    clouds[i].y += clouds[i].speed * CLOUD_SPEED;
                    if (clouds[i].y > gameCanvas.height) clouds.splice(i, 1);
                 }
                 generateClouds(); // Keep generating clouds

                 // Update explosions
                 for (let i = explosions.length - 1; i >= 0; i--) {
                    explosions[i].frameTime++;
                    if (explosions[i].frameTime >= 5) { // Frame duration
                        explosions[i].frame++; explosions[i].frameTime = 0;
                        if (explosions[i].frame >= explosions[i].frames.length) explosions.splice(i, 1);
                    }
                 }
             }


            // State-specific updates
            switch (gameState) {
                case 'playing':
                    // --- Player Movement & Shooting ---
                    const canvasWidth = gameCanvas.width; const canvasHeight = gameCanvas.height;
                    if (keyState[37] || keyState[65]) player.x = Math.max(0, player.x - PLANE_SPEED); // Left (Arrow/A)
                    if (keyState[39] || keyState[68]) player.x = Math.min(canvasWidth - player.width, player.x + PLANE_SPEED); // Right (Arrow/D)
                    if (keyState[38] || keyState[87]) player.y = Math.max(0, player.y - PLANE_SPEED); // Up (Arrow/W)
                    if (keyState[40] || keyState[83]) player.y = Math.min(canvasHeight - player.height, player.y + PLANE_SPEED); // Down (Arrow/S)
                    if (keyState[32]) { // Spacebar
                        const now = Date.now();
                        if (now - lastPlayerShotTime >= PLAYER_FIRE_COOLDOWN) {
                            playerBullets.push({ x: player.x + player.width / 2 - 4, y: player.y, width: 8, height: 16, image: bulletImage }); // Start bullet from front of plane
                            lastPlayerShotTime = now; playShootSound();
                        }
                    }
                    player.frameCount++;

                    // --- Bullet Movement ---
                    for (let i = playerBullets.length - 1; i >= 0; i--) {
                         playerBullets[i].y -= BULLET_SPEED;
                        if (playerBullets[i].y < -playerBullets[i].height) playerBullets.splice(i, 1);
                     }
                    for (let i = enemyBullets.length - 1; i >= 0; i--) {
                         const bullet = enemyBullets[i];
                         // Handle bullets with dx/dy (like boss spread)
                         if (bullet.dx !== undefined && bullet.dy !== undefined) {
                             bullet.x += bullet.dx;
                             bullet.y += bullet.dy;
                         } else {
                             bullet.y += bullet.speed; // Regular speed
                         }
                         if (bullet.y > canvasHeight || bullet.y < -bullet.height || bullet.x < -bullet.width || bullet.x > canvasWidth) {
                              enemyBullets.splice(i, 1);
                         }
                     }

                    // --- Enemy Movement & Generation ---
                    for (let i = enemies.length - 1; i >= 0; i--) {
                         const enemy = enemies[i]; enemy.y += enemy.speed;
                        // Apply movement patterns based on type logic
                        const typeInfo = enemyTypes[enemy.type];
                         switch (enemy.movementPattern) {
                             case 1: // Sine wave
                                 enemy.x += Math.sin(enemy.y / 30 + enemy.patternPhase) * enemy.speed * 1.5;
                                 break;
                             case 2: // Slight homing towards player X
                                 const f = 0.15; // Homing factor
                                 if (enemy.x + enemy.width / 2 < player.x + player.width / 2) { enemy.x += enemy.speed * f; }
                                 else { enemy.x -= enemy.speed * f; }
                                 break;
                             case 3: // Bounce side to side
                                 enemy.x += enemy.speed * 0.7 * enemy.patternDirection;
                                 if (enemy.x <= 0 && enemy.patternDirection < 0) { enemy.patternDirection = 1; enemy.x = 0; }
                                 else if (enemy.x >= canvasWidth - enemy.width && enemy.patternDirection > 0) { enemy.patternDirection = -1; enemy.x = canvasWidth - enemy.width; }
                                 break;
                             case 0: // Straight down (default)
                             default:
                                break;
                        }
                        // Clamp enemy X position
                        enemy.x = Math.max(0, Math.min(canvasWidth - enemy.width, enemy.x));
                        // Remove if off screen bottom
                        if (enemy.y > canvasHeight) enemies.splice(i, 1);
                     }
                    generateEnemies();
                    enemyShoot();

                    // --- Collision Check ---
                    checkCollisions(); // *** CALL THE COLLISION FUNCTION ***

                    // --- Check for Boss Trigger ---
                    if (score >= scoreNeededForNextLevel) {
                        gameState = 'boss_intro';
                        showLevelMessage(`警告! BOSS 来袭!`, 2000);
                        enemies = []; // Clear screen of normal enemies
                        enemyBullets = []; // Clear bullets too
                        // Short delay before boss actually appears
                        setTimeout(() => {
                             spawnBoss();
                             gameState = 'boss_fight';
                        }, 2500); // Wait 2.5 seconds
                    }
                    break;

                case 'boss_intro':
                    // Player can still move, but no shooting/enemies
                     const cw = gameCanvas.width; const ch = gameCanvas.height;
                    if (keyState[37] || keyState[65]) player.x = Math.max(0, player.x - PLANE_SPEED);
                    if (keyState[39] || keyState[68]) player.x = Math.min(cw - player.width, player.x + PLANE_SPEED);
                    if (keyState[38] || keyState[87]) player.y = Math.max(0, player.y - PLANE_SPEED);
                    if (keyState[40] || keyState[83]) player.y = Math.min(ch - player.height, player.y + PLANE_SPEED);
                    // Maybe move existing enemies off screen? (Optional - currently just deleting them)
                    break;

                case 'boss_fight':
                    // --- Player Movement & Shooting (Same as 'playing') ---
                    const cWidth = gameCanvas.width; const cHeight = gameCanvas.height;
                    if (keyState[37] || keyState[65]) player.x = Math.max(0, player.x - PLANE_SPEED);
                    if (keyState[39] || keyState[68]) player.x = Math.min(cWidth - player.width, player.x + PLANE_SPEED);
                    if (keyState[38] || keyState[87]) player.y = Math.max(0, player.y - PLANE_SPEED);
                    if (keyState[40] || keyState[83]) player.y = Math.min(cHeight - player.height, player.y + PLANE_SPEED);
                    if (keyState[32]) {
                        const now = Date.now();
                        if (now - lastPlayerShotTime >= PLAYER_FIRE_COOLDOWN) {
                            playerBullets.push({ x: player.x + player.width / 2 - 4, y: player.y, width: 8, height: 16, image: bulletImage });
                            lastPlayerShotTime = now; playShootSound();
                        }
                    }
                     player.frameCount++;

                    // --- Bullet Movement (Same as 'playing') ---
                     for (let i = playerBullets.length - 1; i >= 0; i--) {
                         playerBullets[i].y -= BULLET_SPEED;
                        if (playerBullets[i].y < -playerBullets[i].height) playerBullets.splice(i, 1);
                      }
                     for (let i = enemyBullets.length - 1; i >= 0; i--) {
                        const bullet = enemyBullets[i];
                         if (bullet.dx !== undefined && bullet.dy !== undefined) { bullet.x += bullet.dx; bullet.y += bullet.dy; }
                         else { bullet.y += bullet.speed; }
                         if (bullet.y > cHeight || bullet.y < -bullet.height || bullet.x < -bullet.width || bullet.x > cWidth) enemyBullets.splice(i, 1);
                      }

                    // --- Boss Update ---
                    updateBoss();

                    // --- Collision Check ---
                    checkCollisions(); // *** CALL THE COLLISION FUNCTION ***
                    break;

                case 'level_transition':
                    // Player can move during transition
                    const ltw = gameCanvas.width; const lth = gameCanvas.height;
                    if (keyState[37] || keyState[65]) player.x = Math.max(0, player.x - PLANE_SPEED);
                    if (keyState[39] || keyState[68]) player.x = Math.min(ltw - player.width, player.x + PLANE_SPEED);
                    if (keyState[38] || keyState[87]) player.y = Math.max(0, player.y - PLANE_SPEED);
                    if (keyState[40] || keyState[83]) player.y = Math.min(lth - player.height, player.y + PLANE_SPEED);
                    // Waiting for timer to switch back to 'playing'
                    // Explosions and clouds are still updating (handled outside switch)
                    break;

                 case 'start_screen':
                 case 'game_over':
                 default:
                     // Do nothing in the main update loop for these states
                    break;
            }
        }


        // Draw game state
        function draw() {
            const canvasWidth = gameCanvas.width;
            const canvasHeight = gameCanvas.height;

            // Clear canvases
            bgCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            gameCtx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Draw background (Stars, Clouds) - Always draw if not on start screen
            if (gameState !== 'start_screen') {
                bgCtx.fillStyle = '#000033'; bgCtx.fillRect(0, 0, canvasWidth, canvasHeight);
                bgCtx.fillStyle = '#ffffff';
                const starCount = Math.floor((canvasWidth * canvasHeight) / 5000);
                for (let i = 0; i < starCount; i++) {
                     const x = Math.random() * canvasWidth; const y = Math.random() * canvasHeight;
                     const size = Math.random() * 1.5 + 0.5; bgCtx.globalAlpha = Math.random() * 0.5 + 0.2; bgCtx.fillRect(x, y, size, size);
                 }
                bgCtx.globalAlpha = 1;
                 clouds.sort((a, b) => a.depth - b.depth);
                 for (const cloud of clouds) {
                     bgCtx.globalAlpha = 0.4 * cloud.depth; const drawWidth = cloud.image.width * cloud.depth * 1.5; const drawHeight = cloud.image.height * cloud.depth * 1.5;
                     if (cloud.y + drawHeight > 0) bgCtx.drawImage(cloud.image, cloud.x, cloud.y, drawWidth, drawHeight);
                 }
                 bgCtx.globalAlpha = 1;
            }


            // --- Draw on Game Layer --- Based on State
            if (gameState !== 'start_screen' && gameState !== 'game_over') {
                const shadowOffsetX = 5; const shadowOffsetY = 5; const shadowAlpha = 0.3;

                // Draw player (if visible and in relevant state)
                if (player.visible && (gameState === 'playing' || gameState === 'boss_intro' || gameState === 'boss_fight' || gameState === 'level_transition')) {
                    let playerAlpha = 1.0;
                    // Flicker if immune
                    if (playerImmune && Math.floor(Date.now() / 100) % 2 === 0) playerAlpha = 0.5;

                    // Draw shadow first
                    gameCtx.globalAlpha = shadowAlpha * playerAlpha;
                    gameCtx.drawImage(playerImage, player.x + shadowOffsetX, player.y + shadowOffsetY, player.width, player.height);

                    // Draw player
                    gameCtx.globalAlpha = playerAlpha;
                    gameCtx.drawImage(playerImage, player.x, player.y, player.width, player.height);

                    // Draw engine flame (pulsating)
                    if (player.frameCount % 6 < 3) gameCtx.fillStyle = '#ff7700'; else gameCtx.fillStyle = '#ffaa00';
                    gameCtx.fillRect(player.x + 22, player.y + player.height - 4, 4, 6); // Position relative to player

                    gameCtx.globalAlpha = 1.0; // Reset alpha
                }

                // Draw player bullets
                for (const bullet of playerBullets) {
                    gameCtx.globalAlpha = shadowAlpha; gameCtx.drawImage(bullet.image, bullet.x + 2, bullet.y + 2, bullet.width, bullet.height);
                    gameCtx.globalAlpha = 1.0; gameCtx.drawImage(bullet.image, bullet.x, bullet.y, bullet.width, bullet.height);
                 }

                // Draw enemy/boss bullets
                for (const bullet of enemyBullets) {
                     gameCtx.globalAlpha = shadowAlpha; gameCtx.drawImage(bullet.image, bullet.x + 2, bullet.y + 2, bullet.width, bullet.height);
                     gameCtx.globalAlpha = 1.0; gameCtx.drawImage(bullet.image, bullet.x, bullet.y, bullet.width, bullet.height);
                 }

                // Draw enemies (only in 'playing' state)
                if (gameState === 'playing') {
                    enemies.sort((a, b) => a.y - b.y); // Draw lower enemies on top
                    for (const enemy of enemies) {
                        gameCtx.globalAlpha = shadowAlpha; gameCtx.drawImage(enemy.image, enemy.x + shadowOffsetX, enemy.y + shadowOffsetY, enemy.width, enemy.height);
                        gameCtx.globalAlpha = 1.0; gameCtx.drawImage(enemy.image, enemy.x, enemy.y, enemy.width, enemy.height);
                     }
                }

                // Draw BOSS (only in 'boss_fight' state)
                 if (gameState === 'boss_fight' && currentBoss) {
                     gameCtx.globalAlpha = shadowAlpha; gameCtx.drawImage(currentBoss.image, currentBoss.x + shadowOffsetX, currentBoss.y + shadowOffsetY, currentBoss.width, currentBoss.height);
                     gameCtx.globalAlpha = 1.0; gameCtx.drawImage(currentBoss.image, currentBoss.x, currentBoss.y, currentBoss.width, currentBoss.height);
                 }

                // Draw explosions (always draw if active, draw after planes/bullets)
                explosions.sort((a, b) => a.y - b.y); // Draw lower explosions on top
                for (const explosion of explosions) {
                     if (explosion.frame < explosion.frames.length) {
                        // Optional: fade out explosion slightly as it progresses
                        gameCtx.globalAlpha = 1.0 - (explosion.frame / explosion.frames.length) * 0.3;
                        gameCtx.drawImage(explosion.frames[explosion.frame], explosion.x, explosion.y, explosion.width, explosion.height);
                        gameCtx.globalAlpha = 1.0;
                    }
                 }
            }
        }

        // --- Fullscreen/Resize Logic --- (Unchanged)
        function resizeGame() { /* ... */
             const width = window.innerWidth; const height = window.innerHeight;
            bgCanvas.width = width; bgCanvas.height = height; gameCanvas.width = width; gameCanvas.height = height;
            bgCtx.imageSmoothingEnabled = false; gameCtx.imageSmoothingEnabled = false;
            if (player) { player.x = Math.max(0, Math.min(width - player.width, player.x)); player.y = Math.max(0, Math.min(height - player.height, player.y)); }
            if (gameState === 'start_screen' || gameState === 'game_over') draw(); // Redraw static screen if needed
            console.log(`Game resized to ${width}x${height}`);
        }

        // Game loop
        function gameLoop() {
            if (gameState !== 'start_screen' && gameState !== 'game_over') {
                update();
            }
            draw(); // Always draw (handles menus indirectly via CSS display)
            requestAnimationFrame(gameLoop);
        }

        // Start game
        function startGame() {
            initializeAudio(); // Ensure audio context is ready on user interaction
            playButtonClickSound();

            // Reset game state variables
            level = 1;
            score = 0;
            playerHealth = 100;
            scoreNeededForNextLevel = calculateScoreNeeded(level);

            enemies = [];
            playerBullets = [];
            enemyBullets = [];
            explosions = [];
            clouds = []; // Clear existing clouds
            currentBoss = null;
            if(levelTransitionTimer) clearTimeout(levelTransitionTimer); // Clear any pending level transition

            keyState = {};
            playerImmune = false;
            lastPlayerShotTime = 0;
            lastEnemySpawn = Date.now(); // Reset spawn timer
            lastEnemyShot = Date.now(); // Reset enemy shoot timer
            enemySpawnInterval = Math.max(200, 1200 - level * 40); // Initial interval based on level 1

            // Position player
            player.x = gameCanvas.width / 2 - player.width / 2;
            player.y = gameCanvas.height - player.height - 50;
            player.visible = true;

            updateUI(); // Update score/health/level display

            // Pre-populate some clouds
            clouds = []; // Make sure it's empty before populating
            for (let i = 0; i < 10; i++) {
                 clouds.push({
                     x: Math.random() * gameCanvas.width,
                     y: Math.random() * gameCanvas.height, // Start some on screen
                     image: createCloudImage(),
                     speed: Math.random() * 0.5 + 0.5,
                     depth: Math.random() * 0.8 + 0.2
                });
            }

            gameState = 'playing'; // Set state to playing

            // Manage screen visibility
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            levelMessageElement.style.display = 'none';
            bossHealthContainer.style.display = 'none';

            console.log("Game started - Level", level, "Score needed:", scoreNeededForNextLevel);
        }


        // Game over
        function gameOver() {
            if (gameState === 'game_over') return; // Prevent multiple triggers

            gameState = 'game_over';
            player.visible = false;
            if(levelTransitionTimer) clearTimeout(levelTransitionTimer); // Stop level transition if game over occurs during it

            finalScoreElement.textContent = '分数: ' + score;
            gameOverScreen.style.display = 'flex';
            playGameOverSound();
            // Play player explosion sound slightly after game over sound
            setTimeout(() => addExplosion(player.x + player.width / 2, player.y + player.height / 2), 50); // Add visual explosion
            setTimeout(() => playExplosionSound(), 100); // Add sound for player explosion
            console.log("Game Over. Final Score:", score);
        }

        // Event listeners
        document.addEventListener('keydown', function(e) { keyState[e.keyCode] = true; });
        document.addEventListener('keyup', function(e) { keyState[e.keyCode] = false; });
        // Use 'click' which works better across browsers than 'onclick' assignment sometimes
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        window.addEventListener('resize', resizeGame);

        // Initialize the game display
        resizeGame(); // Initial sizing
        updateUI(); // Show initial UI (Level 1 / Score 0/XXX)
        // Don't start the loop immediately if you want the start screen visible first
        // Instead, the loop should already be running, but the update() function checks the state.
        // Make sure gameLoop is called once globally to start it.
        gameLoop(); // Start the main game loop

    </script>
</body>
</html>